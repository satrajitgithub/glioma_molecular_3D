#!/usr/bin/env python
# Copyright 2018 Division of Medical Image Computing, German Cancer Research Center (DKFZ).
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

import numpy as np
import os
from collections import OrderedDict
import pandas as pd
import pickle
import time
import subprocess
import utils.dataloader_utils as dutils

# batch generator tools from https://github.com/MIC-DKFZ/batchgenerators
from batchgenerators.dataloading.data_loader import SlimDataLoaderBase
from batchgenerators.transforms.color_transforms import ContrastAugmentationTransform
from batchgenerators.transforms.spatial_transforms import MirrorTransform as Mirror
from batchgenerators.transforms.abstract_transforms import Compose
from batchgenerators.dataloading.multi_threaded_augmenter import MultiThreadedAugmenter
from batchgenerators.dataloading import SingleThreadedAugmenter
from batchgenerators.transforms.spatial_transforms import SpatialTransform
from batchgenerators.transforms.crop_and_pad_transforms import CenterCropTransform
from batchgenerators.transforms.utility_transforms import ConvertSegToBoundingBoxCoordinates

import pprint


def get_train_generators(cf, logger):
    """
    wrapper function for creating the training batch generator pipeline. returns the train/val generators.
    selects patients according to cv folds (generated by first run/fold of experiment):
    splits the data into n-folds, where 1 split is used for val, 1 split for testing and the rest for training. (inner loop test set)
    If cf.hold_out_test_set is True, adds the test split to the training data.
    """
    all_data = load_dataset(cf, logger, cf.pp_data_path)
    all_pids_list = np.unique([v['pid'] for (k, v) in all_data.items()])

    n_train_val_data = len(all_pids_list)
    train_pids = all_pids_list # all train
    # train_pids = all_pids_list[:int(4 * n_train_val_data // 5)] # 4/5th train - 1/5th val
    val_pids = all_pids_list[int(np.ceil(4 * n_train_val_data // 5)):n_train_val_data]

    train_data = {k: v for (k, v) in all_data.items() if any(p == v['pid'] for p in train_pids)}
    val_data = {k: v for (k, v) in all_data.items() if any(p == v['pid'] for p in val_pids)}

    # logger.debug("train_data")
    # pprint.pprint(train_data)

    logger.info("data set loaded with: {} train / {} val patients".format(len(train_pids), len(val_pids)))
    batch_gen = {}
    batch_gen['train'] = create_data_gen_pipeline(train_data, cf=cf, data_augmentation=cf.train_augmentation)
    batch_gen['val_sampling'] = create_data_gen_pipeline(val_data, cf=cf, data_augmentation=False)

    if cf.val_mode == 'val_patient':
        batch_gen['val_patient'] = PatientBatchIterator(val_data, cf=cf)
        batch_gen['n_val'] = len(val_pids) if cf.max_val_patients is None else min(len(val_pids), cf.max_val_patients)
    else:
        batch_gen['n_val'] = cf.num_val_batches

    return batch_gen


def get_test_generator(cf, logger, path_to_data):
    """
    wrapper function for creating the test batch generator pipeline.
    selects patients according to cv folds (generated by first run/fold of experiment)
    If cf.hold_out_test_set is True, gets the data from an external folder instead.
    """
    
    test_data = load_dataset(cf, logger, path_to_data)
    logger.info("data set loaded with: {} test patients from {}".format(len(test_data.keys()), path_to_data))
    batch_gen = {}
    batch_gen['test'] = PatientBatchIterator(test_data, cf=cf)
    batch_gen['n_test'] = len(test_data.keys()) if cf.max_test_patients=="all" else \
        min(cf.max_test_patients, len(test_data.keys()))

    return batch_gen



def load_dataset(cf, logger, pp_data_path):
    """
    loads the dataset. if deployed in cloud also copies and unpacks the data to the working directory.
    :param subset_ixs: subset indices to be loaded from the dataset. used e.g. for testing to only load the test folds.
    :return: data: dictionary with one entry per patient (in this case per patient-breast, since they are treated as
    individual images for training) each entry is a dictionary containing respective meta-info as well as paths to the preprocessed
    numpy arrays to be loaded during batch-generation
    """

    p_df = pd.read_pickle(os.path.join(pp_data_path, cf.input_df_name))

    class_targets = p_df['class_id'].tolist()
    pids = p_df.pid.tolist()
    imgs = [os.path.join(pp_data_path, '{}.npy'.format(pid)) for pid in pids]
    segs = [os.path.join(pp_data_path,'{}.npy'.format(pid)) for pid in pids]
    session_names = [p_df[p_df['pid'] == pid]['subj_id'].iloc[0] for pid in pids]

    data = OrderedDict()
    for ix, pid in enumerate(pids):
        data[pid] = {'data': imgs[ix], 'session_name': session_names[ix], 'seg': segs[ix], 'pid': pid, 'class_target': [class_targets[ix]]}

    return data



def create_data_gen_pipeline(patient_data, cf, data_augmentation=True):
    """
    create mutli-threaded train/val/test batch generation and augmentation pipeline.
    :param patient_data: dictionary containing one dictionary per patient in the train/test subset.
    :param data_augmentation: (optional) whether to perform data augmentation (training) or not (validation/testing)
    :return: multithreaded_generator
    """

    # create instance of batch generator as first element in pipeline.
    data_gen = BatchGenerator(patient_data, batch_size=cf.batch_size, cf=cf)
    
    # print("[DEBUG]")
    # tr_data = data_gen.generate_train_batch()
    # print("tr_data['data']", tr_data['data'].shape) # should of shape (b, c, x, y) or  (b, c, x, y, z)
    # print("tr_data['seg']", tr_data['seg'].shape) # should of shape (b, 1, x, y) or  (b, 1, x, y, z) for binary seg

    # add transformations to pipeline.
    my_transforms = []
    if data_augmentation:
        if 'mirror' in data_augmentation:
            print("[DEBUG] Performing mirror_transform in augmentation")
            mirror_transform = Mirror(axes=np.arange(cf.dim))
            my_transforms.append(mirror_transform)

        if 'contrast' in data_augmentation:
            print("[DEBUG] Performing contrast_transform in augmentation")
            contrast_transform = ContrastAugmentationTransform(cf.da_kwargs['contrast_range'], preserve_range=True)
            my_transforms.append(contrast_transform)

        if 'spatial' in data_augmentation:
            print("[DEBUG] Performing spatial_transform in augmentation")
            spatial_transform = SpatialTransform(patch_size=cf.patch_size[:cf.dim], 
                                                 do_elastic_deform= False,
                                                 do_rotation=cf.da_kwargs['do_rotation'], angle_x=cf.da_kwargs['angle_x'], angle_y=cf.da_kwargs['angle_y'], angle_z=cf.da_kwargs['angle_z'],
                                                 do_scale=False,
                                                 random_crop=False)

            my_transforms.append(spatial_transform)
    else:
        my_transforms.append(CenterCropTransform(crop_size=cf.patch_size[:cf.dim]))

    my_transforms.append(ConvertSegToBoundingBoxCoordinates(cf.dim, get_rois_from_seg_flag=False, class_specific_seg_flag=cf.class_specific_seg_flag))
    all_transforms = Compose(my_transforms)
    # multithreaded_generator = SingleThreadedAugmenter(data_gen, all_transforms)
    multithreaded_generator = MultiThreadedAugmenter(data_gen, all_transforms, num_processes=cf.n_workers, seeds=range(cf.n_workers))
    return multithreaded_generator


class BatchGenerator(SlimDataLoaderBase):
    """
    creates the training/validation batch generator. Samples n_batch_size patients (draws a slice from each patient if 2D)
    from the data set while maintaining foreground-class balance. Returned patches are cropped/padded to pre_crop_size.
    Actual patch_size is obtained after data augmentation.
    :param data: data dictionary as provided by 'load_dataset'.
    :param batch_size: number of patients to sample for the batch
    :return dictionary containing the batch data (b, c, x, y, (z)) / seg (b, 1, x, y, (z)) / pids / class_target
    """
    def __init__(self, data, batch_size, cf):
        super(BatchGenerator, self).__init__(data, batch_size)

        self.cf = cf

    def generate_train_batch(self):

        batch_data, batch_segs, batch_pids, batch_targets = [], [], [], []
        class_targets_list =  [v['class_target'] for (k, v) in self._data.items()]

        #samples patients towards equilibrium of foreground classes on a roi-level (after randomly sampling the ratio "batch_sample_slack).
        batch_ixs = dutils.get_class_balanced_patients(
            class_targets_list, self.batch_size, self.cf.head_classes - 1, slack_factor=self.cf.batch_sample_slack)
        patients = list(self._data.items())

        for b in batch_ixs:

            patient = patients[b][1]
            all_data = np.load(patient['data'], mmap_mode='r')
            # print("all_data", all_data.shape)
            data = all_data[:-1]
            seg = all_data[-1].astype('uint8')
            batch_pids.append(patient['pid'])
            batch_targets.append(patient['class_target'])
            # batch_data.append(data[np.newaxis])
            batch_data.append(data)
            batch_segs.append(seg[np.newaxis])

        data = np.array(batch_data)
        seg = np.array(batch_segs).astype(np.uint8)
        class_target = np.array(batch_targets)
        return {'data': data, 'seg': seg, 'pid': batch_pids, 'class_target': class_target}



class PatientBatchIterator(SlimDataLoaderBase):
    """
    creates a test generator that iterates over entire given dataset returning 1 patient per batch.
    Can be used for monitoring if cf.val_mode = 'patient_val' for a monitoring closer to actualy evaluation (done in 3D),
    if willing to accept speed-loss during training.
    :return: out_batch: dictionary containing one patient with batch_size = n_3D_patches in 3D or
    batch_size = n_2D_patches in 2D .
    """
    def __init__(self, data, cf): #threads in augmenter
        super(PatientBatchIterator, self).__init__(data, 0)
        self.cf = cf
        self.patient_ix = 0
        self.dataset_pids = [v['pid'] for (k, v) in data.items()]
        self.patch_size = cf.patch_size
        if len(self.patch_size) == 2:
            self.patch_size = self.patch_size + [1]


    def generate_train_batch(self):

        pid = self.dataset_pids[self.patient_ix]
        patient = self._data[pid]
        all_data = np.load(patient['data'], mmap_mode='r')
        data = all_data[:-1]
        seg = all_data[-1].astype('uint8')
        batch_class_targets = np.array([patient['class_target']])
        session_names = np.array([patient['session_name']])

        out_data = data[None] # should be of shape (b, c, x, y, (z)) 
        out_seg = seg[None, None] # should be of shape (b, 1, x, y, (z)) for binary seg or (b, #seg_classes, x, y, (z)) for multi-class seg

        # print('check patient data loader', out_data.shape, out_seg.shape)
        batch_2D = {'data': out_data, 'seg': out_seg, 'class_target': batch_class_targets, 'pid': pid, 'session_name': session_names}
        converter = ConvertSegToBoundingBoxCoordinates(dim=self.cf.dim, get_rois_from_seg_flag=False, class_specific_seg_flag=self.cf.class_specific_seg_flag)
        batch_2D = converter(**batch_2D)

        batch_2D.update({'patient_bb_target': batch_2D['bb_target'],
                         'patient_roi_labels': batch_2D['roi_labels'],
                         'original_img_shape': out_data.shape})

        self.patient_ix += 1
        if self.patient_ix == len(self.dataset_pids):
            self.patient_ix = 0

        return batch_2D





